# Maven Simulation System Analysis

## Overview

Maven includes its own Monte Carlo simulation system for generating leave value tables. This means the MUL resources were likely generated by Maven itself, not a separate tool.

## Evidence for Built-in Simulation

1. **Heavy FP Usage in Specific CODE Resources**
   - CODE 35: 22 SANE FP calls (statistics calculations)
   - CODE 50: 25 SANE FP calls (result accumulation and storage)
   - Most other CODE resources: 0 FP calls (integer-only)

2. **Resource Writing Capability**
   - CODE 50: Has ChangedResource (A9AA) call - can modify resources
   - CODE 15: Contains 'MUL' string - loads MUL resources by type

3. **MUL Resource Metadata**
   - Sample counts in billions (offset 16-19)
   - IEEE doubles for averaged results (offset 0-7)
   - Integer extracts for runtime use (offset 24-27)

4. **User Observable Behavior**
   - Maven has a "simulation" mode that was running during our analysis
   - The application can run self-play games

## Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                    SIMULATION SYSTEM                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐  │
│  │  CODE 3  │───▶│ CODE 35  │───▶│ CODE 50  │───▶│   MUL    │  │
│  │  Search  │    │   FP     │    │  Store   │    │Resources │  │
│  │  Engine  │    │  Stats   │    │ Results  │    │          │  │
│  └──────────┘    └──────────┘    └──────────┘    └──────────┘  │
│       │                                                │        │
│       │         RUNTIME PATH                           │        │
│       │                                                ▼        │
│       │          ┌──────────┐    ┌──────────┐    ┌──────────┐  │
│       └─────────▶│ CODE 15  │───▶│ CODE 32  │───▶│  Move    │  │
│                  │  Load    │    │  Apply   │    │  Eval    │  │
│                  │   MUL    │    │  Leave   │    │          │  │
│                  └──────────┘    └──────────┘    └──────────┘  │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

## CODE Resource Roles

### Simulation Path (FP-heavy)

| CODE | Size | FP Calls | Purpose |
|------|------|----------|---------|
| 35 | 3276 | 22 | SANE FP score calculation, statistical aggregation |
| 50 | 1178 | 25 | Result accumulation, resource updates |

### Runtime Path (Integer)

| CODE | Size | FP Calls | Purpose |
|------|------|----------|---------|
| 15 | 3568 | 0 | DAWG traversal, MUL resource loading |
| 32 | 6464 | 7 | Move scoring, leave value application |

## CODE 35 Analysis

**Purpose**: Extended precision arithmetic for simulation statistics

Key operations:
- 0x0060: `calc_extended_product` - multiply extended precision values
- 0x0168: `score_calculation_main` - main statistical calculation
- 0x0310: `sum_word_values` - accumulate scores
- 0x0368: `full_score_calculation` - comprehensive evaluation

SANE operations used:
- FADDX (0x0002) - add extended
- FMULX (0x0004) - multiply extended
- FDIVX (0x0006) - divide extended
- FCMPX (0x2008) - compare extended
- To/from extended conversions

The FP is necessary for computing accurate averages over millions of simulated games.

## CODE 50 Analysis

**Purpose**: Store simulation results to resources

Key features:
- Works with 'HIST' resources (may be simulation history)
- Calls ChangedResource (A9AA) to mark modified
- Heavy FP for computing final values before storage
- Contains FP constants at end of code

The 25 SANE calls suggest it's doing significant computation before storing, not just I/O.

## Why FP for Simulation?

1. **Averaging**: Computing mean scores across billions of games produces fractional values
2. **Precision**: Small differences in leave values (0.1 points) require FP precision
3. **Variance**: May compute variance/confidence intervals
4. **Normalization**: Converting raw counts to probabilities

## Why Integer for Runtime?

1. **Speed**: Integer operations much faster on 68000
2. **Sufficient Precision**: Centipoints (1/100) give 2 decimal places
3. **Lookup**: Pre-computed values just need indexing
4. **Comparison**: Integer comparison faster than FP

## MUL Resource Format (Confirmed)

Each MUL resource contains 28-byte records indexed by tile copy count:

```
Offset  Size  Type     Purpose
------  ----  ----     -------
0       8     double   Expected turn score (simulation output)
8       8     double   Secondary value (possibly variance)
16      4     uint32   Sample count (billions of games)
20      4     int32    Unknown
24      4     int32    Leave adjustment (runtime lookup value)
```

The simulation fills offsets 0-23, then extracts the integer at offset 24 for fast runtime access.

## Open Questions

1. **Trigger**: How does the user start a simulation run?
2. **Duration**: How long do simulations run? (Sample counts suggest hours/days)
3. **Parameters**: Can simulation parameters be configured?
4. **Formula**: What exact formula converts simulation results to offset-24 integers?

## Implications

Since Maven includes its own simulation system:
- Users could potentially regenerate leave values for custom dictionaries
- The simulation code shows the "ground truth" leave value calculation
- Understanding CODE 35 and 50 would reveal the exact formula
